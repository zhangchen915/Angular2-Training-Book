<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    <title>Angular Training Book |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/Angular2-Training-Book/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/Angular2-Training-Book/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"why_TypeScript.html","title":""},"data":{"navigation":{"logo":{"text":"Angular","type":"link","path":"index.html"},"main":[{"text":"License","type":"link","path":"license.html"},{"text":"Why Angular ? ","type":"link","path":"why_angular_2.html"},{"text":"为什么不是React⚡️","type":"link","path":"vs_react.html"},{"text":"聊聊技术选型-Angular vs Vue⚡️","type":"link","path":"vs_vue2.html"},{"text":"ES6和TypeScript的特点","type":"link","path":"ES6&TypeScript/ES6&TypeScript.html","children":[{"text":"ES6","type":"link","path":"ES6&TypeScript/es6/es6.html"},{"text":"Classes","type":"link","path":"ES6&TypeScript/es6/classes.html"},{"text":"回顾 `this`","type":"link","path":"ES6&TypeScript/es6/refresher_on_this.html"},{"text":"箭头函数","type":"link","path":"ES6&TypeScript/es6/arrow_functions.html"},{"text":"模板字符串","type":"link","path":"ES6&TypeScript/es6/template_strings.html"},{"text":"继承","type":"link","path":"ES6&TypeScript/es6/inheritance.html"},{"text":"委托","type":"link","path":"ES6&TypeScript/es6/delegation.html"},{"text":"常量和块作用域变量","type":"link","path":"ES6&TypeScript/es6/constants_and_block_scoped_variables.html"},{"text":"扩展语句和剩余参数","type":"link","path":"ES6&TypeScript/es6/spread_and_rest.html"},{"text":"解构","type":"link","path":"ES6&TypeScript/es6/destructuring.html"},{"text":"模块","type":"link","path":"ES6&TypeScript/es6/es6_modules.html"},{"text":"TypeScript","type":"link","path":"ES6&TypeScript/typescript/typeScript.html"},{"text":"TypeScript入门","type":"link","path":"ES6&TypeScript/typescript/typeScript_start.html"},{"text":"使用 tsc","type":"link","path":"ES6&TypeScript/typescript/working_with_tsc.html"},{"text":"Linting","type":"link","path":"ES6&TypeScript/typescript/linting.html"},{"text":"类型⚡️","type":"link","path":"ES6&TypeScript/typescript/typings.html"},{"text":"TypeScript特性","type":"link","path":"ES6&TypeScript/typescript/typescript_features.html"},{"text":"TypeScript类","type":"link","path":"ES6&TypeScript/typescript/typescript_classes.html"},{"text":"泛型⚡️","type":"link","path":"ES6&TypeScript/typescript/generics.html"},{"text":"接口","type":"link","path":"ES6&TypeScript/typescript/interfaces.html"},{"text":"Shapes","type":"link","path":"ES6&TypeScript/typescript/shapes.html"},{"text":"类型推断","type":"link","path":"ES6&TypeScript/typescript/type_inference.html"},{"text":"类型关键字","type":"link","path":"ES6&TypeScript/typescript/type_keyword.html"},{"text":"装饰器","type":"link","path":"ES6&TypeScript/typescript/decorators.html"},{"text":"属性装饰器","type":"link","path":"ES6&TypeScript/typescript/property_decorators.html"},{"text":"类装饰器","type":"link","path":"ES6&TypeScript/typescript/class_decorators.html"},{"text":"参数装饰器","type":"link","path":"ES6&TypeScript/typescript/parameter_decorators.html"}]},{"text":"JavaScript工具链","type":"link","path":"tooling/tooling.html","children":[{"text":"源码控制： Git","type":"link","path":"tooling/source_control.html"},{"text":"命令行","type":"link","path":"tooling/the_command_line.html"},{"text":"JavaScript命令行： NodeJS","type":"link","path":"tooling/command_line_javascript.html"},{"text":"后端代码共享和分发： npm","type":"link","path":"tooling/back_end_code_sharing_and_distribution.html"},{"text":"模块加载， 打包和构建任务： Webpack","type":"link","path":"tooling/module_loading_bundling_and_build_tasks.html"},{"text":"Chrome","type":"link","path":"tooling/chrome.html"}]},{"text":"引导Angular应用","type":"link","path":"bootstrapping/bootstrapping.html","children":[{"text":"了解文件结构","type":"link","path":"bootstrapping/file_structure.html"},{"text":"引导Providers","type":"link","path":"bootstrapping/bootstrapping_providers.html"}]},{"text":"Angular 中的组件","type":"link","path":"Components/components.html","children":[{"text":"创建组件","type":"link","path":"Components/creating_components.html"},{"text":"组件的应用程序结构","type":"link","path":"Components/app_structure_with_components.html","children":[{"text":"将数据传递到组件","type":"link","path":"Components/passing_data_into_components.html"},{"text":"响应组件事件","type":"link","path":"Components/responding_to_component_events.html"},{"text":"使用双向数据绑定","type":"link","path":"Components/two_way_data_binding.html"},{"text":"从模板访问子组件","type":"link","path":"Components/access_child_components_from_template.html"}]},{"text":"投影","type":"link","path":"Components/projection.html"},{"text":"使用组件构建应用程序","type":"link","path":"Components/structuring_applications_with_components.html"},{"text":"使用其他组件","type":"link","path":"Components/using_other_components.html"}]},{"text":"指令","type":"link","path":"Directives/directives.html","children":[{"text":"属性指令","type":"link","path":"Directives/attribute_directives.html","children":[{"text":"NgStyle指令","type":"link","path":"Directives/ng_style_directive.html"},{"text":"NgClass指令","type":"link","path":"Directives/ng_class_directive.html"}]},{"text":"结构指令","type":"link","path":"Directives/structural_directives.html","children":[{"text":"NgIf指令","type":"link","path":"Directives/ng_if_directive.html"},{"text":"NgFor指令","type":"link","path":"Directives/ng_for_directive.html"},{"text":"NgSwitch指令","type":"link","path":"Directives/ng_switch_directives.html"},{"text":"使用多个结构指令","type":"link","path":"Directives/using_multiple_structural_directives.html"}]}]},{"text":"高级组件","type":"link","path":"advanced-components/advanced-components.html","children":[{"text":"组件生命周期","type":"link","path":"advanced-components/component_lifecycle.html"},{"text":"其他组件交互方式","type":"link","path":"advanced-components/access_child_components.html"},{"text":"视图封装","type":"link","path":"advanced-components/view_encapsulation.html"},{"text":"ElementRef","type":"link","path":"advanced-components/elementref.html"}]},{"text":"Observable","type":"link","path":"Observables/observables.html","children":[{"text":"使用Observable","type":"link","path":"Observables/using_observables.html"},{"text":"错误处理","type":"link","path":"Observables/error_handling.html"},{"text":"处理订阅和释放资源","type":"link","path":"Observables/disposing_subscriptions_and_releasing_resources.html"},{"text":"Observable VS Promise","type":"link","path":"Observables/observables_vs_promises.html"},{"text":"使用其他来源的Observable","type":"link","path":"Observables/using_observables_from_other_sources.html"},{"text":"可观察数组操作","type":"link","path":"Observables/observables_array_operations.html"},{"text":"“冷” vs“ 热” Observable","type":"link","path":"Observables/cold_vs_hot_observables.html"},{"text":"总结","type":"link","path":"Observables/summary.html"}]},{"text":"Angular 依赖注入","type":"link","path":"Di/di.html","children":[{"text":"什么是DI？","type":"link","path":"Di/what_is_di.html"},{"text":"DI框架","type":"link","path":"Di/di_framework.html"},{"text":"Angular 的DI","type":"link","path":"Di/angular2_di.html","children":[{"text":"@Inject() 和 @Injectable","type":"link","path":"Di/inject_and_injectable.html"},{"text":"类以外的注入","type":"link","path":"Di/injection_beyond_classes.html"},{"text":"避免注入冲突: OpaqueToken","type":"link","path":"Di/avoiding_collisions_opaque_token.html"},{"text":"注入树","type":"link","path":"Di/the_injector_tree.html"}]}]},{"text":"HTTP","type":"link","path":"Http/http.html","children":[{"text":"发起请求","type":"link","path":"Http/making_requests.html"},{"text":"捕获异常","type":"link","path":"Http/catching-rejections.html","children":[{"text":"捕获和释放","type":"link","path":"Http/catch_and_release.html"},{"text":"取消请求","type":"link","path":"Http/cancel_request.html"},{"text":"重试","type":"link","path":"Http/retry.html"}]},{"text":"拦截请求","type":"link","path":"Http/interceptor.html"},{"text":"进度事件","type":"link","path":"Http/progress.html"}]},{"text":"变化检测","type":"link","path":"Change-detection/Change_Detection.html","children":[{"text":"Angularjs与Angular的变化检测策略","type":"link","path":"Change-detection/angular_1_vs_angular_2.html"},{"text":"变化检测如何工作","type":"link","path":"Change-detection/how_change_detection_works.html"},{"text":"更改检测器类","type":"link","path":"Change-detection/change_detector_classes.html"},{"text":"变更检测策略： OnPush","type":"link","path":"Change-detection/change_detection_strategy_onpush.html"},{"text":"强制不变性","type":"link","path":"Change-detection/enforcing_immutability.html"},{"text":"其他资源","type":"link","path":"Change-detection/additional_resources.html"}]},{"text":"Zone.js","type":"link","path":"zone/zone.html","children":[{"text":"概述","type":"link","path":"zone/zone_primer.html"},{"text":"Zone 传播","type":"link","path":"zone/zone-propagation.html"},{"text":"跟踪异步操作","type":"link","path":"zone/tracking_async_operations.html"},{"text":"异步操作补丁","type":"link","path":"zone/patching_async_methods.html"},{"text":"上下文环境","type":"link","path":"zone/context_propagation.html"},{"text":"拦截","type":"link","path":"zone/interception.html"}]},{"text":"Angular 进阶","type":"link","path":"Advanced-angular/advanced-angular.html","children":[{"text":"指令","type":"link","path":"Advanced-angular/directives.html","children":[{"text":"创建属性指令","type":"link","path":"Advanced-angular/creating_an_attribute_directive.html","children":[{"text":"监听Host元素","type":"link","path":"Advanced-angular/listening_to_an_element_host.html"},{"text":"在指令中设置属性","type":"link","path":"Advanced-angular/setting_properties_in_a_directive.html"}]},{"text":"创建结构指令","type":"link","path":"Advanced-angular/creating_a_structural_directive.html","children":[{"text":"查看容器和嵌入视图","type":"link","path":"Advanced-angular/view_containers_and_embedded_views.html"},{"text":"向指令提供上下文变量","type":"link","path":"Advanced-angular/providing_context_variables_to_directives.html"}]}]},{"text":"AoT","type":"link","path":"Advanced-angular/aot.html","children":[{"text":"AoT局限","type":"link","path":"Advanced-angular/aot_limitations.html"},{"text":"AoT配置","type":"link","path":"Advanced-angular/aot_config.html"}]}]},{"text":"Immutable.js","type":"link","path":"Immutable/immutable.html","children":[{"text":"什么是不可变性？","type":"link","path":"Immutable/what_is_immutability.html"},{"text":"不变性的应用场景","type":"link","path":"Immutable/the_case_for_immutability.html"},{"text":"JavaScript解决方案","type":"link","path":"Immutable/javascript-solutions.html"},{"text":"Object.assign","type":"link","path":"Immutable/object_assign.html"},{"text":"Object.freeze","type":"link","path":"Immutable/object_freeze.html"},{"text":"Immutable.js基础","type":"link","path":"Immutable/immutable-js.html","children":[{"text":"Immutable.Map","type":"link","path":"Immutable/maps.html"},{"text":"Map.merge","type":"link","path":"Immutable/map_merge.html"},{"text":"嵌套对象","type":"link","path":"Immutable/nested-objects.html"},{"text":"删除密钥","type":"link","path":"Immutable/deleting_keys.html"},{"text":"Map是可迭代的","type":"link","path":"Immutable/maps_are_iterable.html"},{"text":"Immutable.List","type":"link","path":"Immutable/lists.html"},{"text":"性能和瞬态变化","type":"link","path":"Immutable/performance-transient-changes.html"},{"text":"官方文件","type":"link","path":"Immutable/official-documentation.html"}]}]},{"text":"管道","type":"link","path":"Pipes/pipes.html","children":[{"text":"使用管道","type":"link","path":"Pipes/using_pipes.html"},{"text":"自定义管道","type":"link","path":"Pipes/custom_pipes.html"},{"text":"状态管道","type":"link","path":"Pipes/stateful_and_async_pipes.html"}]},{"text":"表单","type":"link","path":"Form/form.html","children":[{"text":"入门","type":"link","path":"Form/getting-started.html"},{"text":"模板驱动的表单","type":"link","path":"Form/template-driven_forms.html","children":[{"text":"嵌套表单数据","type":"link","path":"Form/nested-form-data.html"},{"text":"使用模板模型绑定","type":"link","path":"Form/template-model-binding.html"},{"text":"验证模板驱动的表单","type":"link","path":"Form/validating_forms.html"}]},{"text":"响应式/模型驱动的表单","type":"link","path":"Form/reactive-forms.html","children":[{"text":"响应式表单基础","type":"link","path":"Form/reactive-forms_basics.html"},{"text":"验证响应式表单","type":"link","path":"Form/reactive-forms_validation.html"},{"text":"自定义验证响应式表单","type":"link","path":"Form/reactive-forms_custom_validation.html"}]},{"text":"用户的视觉提示","type":"link","path":"Form/visual_cues_for_users.html"}]},{"text":"模块","type":"link","path":"Modules/modules.html","children":[{"text":"什么是Angular模块？","type":"link","path":"Modules/introduction.html"},{"text":"将组件、 管道和服务添加到模块","type":"link","path":"Modules/multiple-elements.html"},{"text":"创建功能模块","type":"link","path":"Modules/feature-modules.html"},{"text":"指令复制","type":"link","path":"Modules/directive-duplications.html"},{"text":"延迟加载模块","type":"link","path":"Modules/lazy-loading-module.html"},{"text":"延迟加载和依赖注入树","type":"link","path":"Modules/lazy-load-di.html"},{"text":"共享模块和依赖注入","type":"link","path":"Modules/shared-modules-di.html"},{"text":"共享相同的依赖注入树","type":"link","path":"Modules/shared-di-tree.html"}]},{"text":"路由","type":"link","path":"Routing/routing.html","children":[{"text":"为什么选择路由？","type":"link","path":"Routing/why_routing.html"},{"text":"配置路由","type":"link","path":"Routing/config.html"},{"text":"将路由器重定向到另一条路由","type":"link","path":"Routing/redirects.html"},{"text":"定义路由之间的链接","type":"link","path":"Routing/routerlink.html"},{"text":"动态添加路由组件","type":"link","path":"Routing/routeroutlet.html"},{"text":"使用路由参数","type":"link","path":"Routing/routeparams.html"},{"text":"定义子路由","type":"link","path":"Routing/child_routes.html"},{"text":"路由拦截","type":"link","path":"Routing/route_guards.html"},{"text":"将可选参数传递给路由","type":"link","path":"Routing/query_params.html"},{"text":"使用辅助路由","type":"link","path":"Routing/aux-routes.html"}]},{"text":"状态管理","type":"link","path":"state-management/state-management.html","children":[{"text":"Redux 和 @ngrx","type":"link","path":"statemanagement/Redux.html"},{"text":"将 @ngrx添加到你的项目","type":"link","path":"statemanagement/adding_ngrx_to_your_project.html"},{"text":"定义应用的主状态","type":"link","path":"statemanagement/defining_your_main_application_state.html"},{"text":"示例应用","type":"link","path":"state-management/example_application.html"},{"text":"使用选择器读取应用程序状态","type":"link","path":"state-management/reading_your_application_state_using_selectors.html"},{"text":"Actions","type":"link","path":"state-management/actions.html"},{"text":"通过Dispatching Actions 修改应用 State","type":"link","path":"state-management/modifying_your_application_state_by_dispatching_actions.html"},{"text":"Reducers 和纯函数","type":"link","path":"state-management/reducers_and_pure_functions.html"},{"text":"Reducers 的 State 管理","type":"link","path":"state-management/reducers_as_state_management.html"},{"text":"创建应用的Root Reducer","type":"link","path":"state-management/creating_your_applications_root_reducer.html"},{"text":"配置你的应用","type":"link","path":"state-management/configuring_your_application.html"},{"text":"更多Redux和Ngrx资源","type":"link","path":"state-management/getting_more_from_redux_and_ngrx.html"}]},{"text":"动画","type":"link","path":"animation/index.html"},{"text":"TDD测试","type":"link","path":"Testing/testing.html","children":[{"text":"测试工具链","type":"link","path":"Testing/toolchain.html"},{"text":"测试设置","type":"link","path":"Testing/setup.html","children":[{"text":"文件名约定","type":"link","path":"Testing/filename-conventions.html"},{"text":"Karma配置","type":"link","path":"Testing/karma-config.html"},{"text":"TestBed配置（ 可选）","type":"link","path":"Testing/testbed-configuration.html"},{"text":"类型","type":"link","path":"Testing/typings.html"},{"text":"执行测试脚本","type":"link","path":"Testing/execute.html"}]},{"text":"简单测试","type":"link","path":"Testing/simple-test.html"},{"text":"使用Chai","type":"link","path":"Testing/using-chai.html"},{"text":"测试组件","type":"link","path":"Testing/components.html","children":[{"text":"检验方法和属性","type":"link","path":"Testing/verify.html"},{"text":"注入依赖和DOM更改","type":"link","path":"Testing/injecting-dependencies.html"},{"text":"覆盖测试的组件","type":"link","path":"Testing/overriding.html"},{"text":"测试异步操作","type":"link","path":"Testing/async.html"},{"text":"重构难以测试的代码","type":"link","path":"Testing/refactor.html"}]},{"text":"测试服务","type":"link","path":"Testing/services.html","children":[{"text":"服务测试策略","type":"link","path":"Testing/strategies.html"},{"text":"测试HTTP请求","type":"link","path":"Testing/http.html"},{"text":"使用MockBackend","type":"link","path":"Testing/mockbackend.html"},{"text":"替代HTTP Mock策略","type":"link","path":"Testing/alt-http-mocking.html"},{"text":"测试JSONP和XHR后端","type":"link","path":"Testing/json-xhr.html"},{"text":"异步执行测试","type":"link","path":"Testing/async -execution.html"}]},{"text":"测试Redux","type":"link","path":"Testing/redux.html","children":[{"text":"测试简单的Action","type":"link","path":"Testing/simple-actions.html"},{"text":"测试复杂的Action","type":"link","path":"Testing/complex-actions.html"},{"text":"测试Reducers","type":"link","path":"Testing/reducers.html"},{"text":"Afterthoughts","type":"link","path":"Testing/after-thoughts.html"}]}]},{"text":"项目设置","type":"link","path":"Project-setup/project-setup.html","children":[{"text":"Webpack","type":"link","path":"Project-setup/webpack.html"},{"text":"安装和使用","type":"link","path":"Project-setup/installation_and_usage.html"},{"text":"Loaders","type":"link","path":"Project-setup/loaders.html"},{"text":"插件","type":"link","path":"Project-setup/plugins.html"},{"text":"概要","type":"link","path":"Project-setup/summary.html"},{"text":"NPM脚本集成","type":"link","path":"Project-setup/npm_scripts_integration.html"}]},{"text":"Angular CLI","type":"link","path":"Angular-CLI/cli.html","children":[{"text":"创建","type":"link","path":"Angular-CLI/setup.html"},{"text":"创建新应用程序","type":"link","path":"Angular-CLI/creating-an-app.html"},{"text":"启动应用","type":"link","path":"Angular-CLI/serving-the-app.html"},{"text":"创建组件","type":"link","path":"Angular-CLI/creating-components.html"},{"text":"创建路由","type":"link","path":"Angular-CLI/creating-routes.html"},{"text":"创建其他东西","type":"link","path":"Angular-CLI/creating-other-things.html"},{"text":"测试","type":"link","path":"Angular-CLI/testing.html"},{"text":"Linting","type":"link","path":"Angular-CLI/linting.html"},{"text":"CLI命令概述","type":"link","path":"Angular-CLI/command-overview.html"},{"text":"添加第三方库","type":"link","path":"Angular-CLI/adding-third-party-libraries.html"},{"text":"集成现有应用程序","type":"link","path":"Angular-CLI/init.html"}]},{"text":"Angular 中的无障碍","type":"link","path":"a11y/a11y.html","children":[{"text":"为什么需要无障碍","type":"link","path":"a11y/why-a11y.html"}]},{"text":"Angular 中的国际化","type":"link","path":"i18n/i18n.html","children":[{"text":"过程什么样的， 如何参与？","type":"link","path":"i18n/process-and-roles.html"},{"text":"在我们的模板中标记文字","type":"link","path":"i18n/marking-text-in -templates.html"},{"text":"使用Angular CLI提取翻译文本","type":"link","path":"i18n/translation-text-extraction.html"},{"text":"如何导入已完成的翻译文件","type":"link","path":"i18n/import -translation - files.html ","children":[{"text":"使用AoT编译器","type":"link","path":"i18n/import -using - aot.html "},{"text":"使用JiT编译器","type":"link","path":"i18n/import -using - jit.html "}]}]},{"text":"词汇表","type":"link","path":"glossary.html"},{"text":"最佳实践与填坑的积累⚡️","type":"link","path":"practice.html"},{"text":"进一步阅读和参考","type":"link","path":"further-reading.html"}]}},"config":{"timezone":"UTC","root":"/Angular2-Training-Book/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico","google_analytics":"UA-85094676-2"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/Angular2-Training-Book/index.html" class="doc-navbar__logo"><img src="/Angular2-Training-Book/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Angular</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="Angular-Why-TypeScript"><a href="#Angular-Why-TypeScript" class="headerlink" title="Angular: Why TypeScript?"></a>Angular: Why TypeScript?</h1><p><img src="assets/ts.png" alt=""></p>
<p>Angular 2 is written in TypeScript. In this article I will talk about why we made the decision. I’ll also share my experience of working with TypeScript: how it affects the way I write and refactor my code.</p>
<h4 id="I-like-TypeScript-but-you-don’t-have-to"><a href="#I-like-TypeScript-but-you-don’t-have-to" class="headerlink" title="I like TypeScript, but you don’t have to"></a>I like TypeScript, but you don’t have to</h4><p>Even though Angular 2 is written in TypeScript, you don’t have to use it to write Angular 2 applications. The framework also works great with ES5, ES6, and Dart.</p>
<h4 id="TypeScript-Has-Great-Tools"><a href="#TypeScript-Has-Great-Tools" class="headerlink" title="TypeScript Has Great Tools"></a>TypeScript Has Great Tools</h4><p>The biggest selling point of TypeScript is tooling. <strong>It provides advanced autocompletion, navigation, and refactoring. Having such tools is almost a requirement for large projects. </strong>Without them the fear changing the code puts the code base in a semi-read-only state, and makes large-scale refactorings very risky and costly.</p>
<p>TypeScript is not the only typed language that compiles to JavaScript. There are other languages with stronger type systems that in theory can provide absolutely phenomenal tooling. But in practice most of them do not have anything other than a compiler. <strong>This is because building rich dev tools has to be an explicit goal from day one, which it has been for the TypeScript team. </strong>That is why they built language services that can be used by editors to provide type checking and autocompletion. If you have wondered why there are so many editors with great TypeScript supports, the answer is the language services.</p>
<p>The fact that intellisense and basic refactorings (e.g., rename a symbol) are reliable makes a huge impact on the process of writing and especially refactoring code. Although it is hard to measure, I feel that the refactorings that would have taken a few days before now can be done in less than a day.</p>
<p>While TypeScript greatly improves the code editing experience, it makes the dev setup more complex, especially comparing to dropping an ES5 script on a page. In addition, you cannot use tools analyzing JavaScript source code (e.g., JSHint), but there are usually adequate replacements.</p>
<h4 id="TypeScript-is-a-Superset-of-JavaScript"><a href="#TypeScript-is-a-Superset-of-JavaScript" class="headerlink" title="TypeScript is a Superset of JavaScript"></a>TypeScript is a Superset of JavaScript</h4><p>Since TypeScript is a superset of JavaScript, you don’t need to go through a big rewrite to migrate to it. You can do it gradually, one module at a time.</p>
<p>Just pick a module, rename the .js files into .ts, then incrementally add type annotations. When you are done with this module, pick the next one. Once the whole code base is typed, you can start tweaking the compiler settings to make it more strict.</p>
<p>This process can take some time, but it was not a big problem for Angular 2, when we were migrating to TypeScript. Doing it gradually allowed us to keep developing new functionality and fixing bugs during the transition.</p>
<h4 id="TypeScript-Makes-Abstractions-Explicit"><a href="#TypeScript-Makes-Abstractions-Explicit" class="headerlink" title="TypeScript Makes Abstractions Explicit"></a>TypeScript Makes Abstractions Explicit</h4><p><strong>A good design is all about well-defined interfaces. And it is much easier to express the idea of an interface in a language that supports them.</strong></p>
<p>For instance, imagine a book-selling application where a purchase can be made by either a registered user through the UI or by an external system through some sort of an API.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/0*47m053Nw8olCUOEi.png" alt="img"></p>
<p>As you can see, both classes play the role of a purchaser. Despite being extremely important for the application, the notion of a purchaser is not clearly expressed in the code. There is no file named purchaser.js. And as a result, it is possible for someone modifying the code to miss the fact that this role even exists.</p>
<p>It is hard, just by looking at the code to tell what objects can play the role of a purchaser, and what methods this role has. We do not know for sure, and we will not get much help from our tools. We have to infer this information manually, which is slow and error-prone.</p>
<p>Now, compare it with a version where we explicitly define the Purchaser interface.</p>
<p>The typed version clearly states that we have the Purchaser interface, and the User and ExternalSystem classes implement it. So TypeScript interfaces allow us to define abstractions/protocols/roles.</p>
<p><strong>It is important to realize that TypeScript does not force us to introduce extra abstractions.</strong> The Purchaser abstraction is present in the JavaScript version of the code, but it is not explicitly defined.</p>
<p><strong>In a statically-typed language, boundaries between subsystems are defined using interfaces. Since JavaScript lacks interfaces, boundaries are not well expressed in plain JavaScript. Not being able to clearly see the boundaries, developers start depending on concrete types instead of abstract interfaces, which leads to tight coupling.</strong></p>
<p>My experience of working on Angular 2 before and after our transition to TypeScript reinforced this belief. Defining an interface forces me to think about the API boundaries, helps me define the public interfaces of subsystems, and exposes incidental coupling.</p>
<h4 id="TypeScript-Makes-Code-Easier-to-Read-and-Understand"><a href="#TypeScript-Makes-Code-Easier-to-Read-and-Understand" class="headerlink" title="TypeScript Makes Code Easier to Read and Understand"></a>TypeScript Makes Code Easier to Read and Understand</h4><p>Yes, I know it does not seem intuitive. Let me try to illustrate what I mean with an example. Let’s look at this function jQuery.ajax(). What kind of information can we get from its signature?</p>
<p>The only thing we can tell for sure is that the function takes two arguments. We can guess the types. Maybe the first one is a string and the second one is a configuration object. But it is just a guess, and we might be wrong. We have no idea what options go into the settings object (neither their names nor their types), or what this function returns.</p>
<p>There is no way we can call this function without checking the source code or the documentation. Checking the source code is not a good option — the point of having functions and classes is to be able to use them without knowing how they are implemented. In other words, we should rely on their interfaces, not on their implementation. We can check the documentation, but it is not the best developer experience — it takes additional time, and the docs are often out-of-date.</p>
<p>So although it is easy to read jQuery.ajax(url, settings), to really understand how to call this function we need to either read its implementation or its docs.</p>
<p>Now, contrast it with a typed version.</p>
<p>It gives us a lot more information.</p>
<ul>
<li>The first argument of this function is a string.</li>
<li>The settings argument is optional. We can see all the options that can be passed into the function, and not only their names, but also their types.</li>
<li>The function returns a JQueryXHR object, and we can see its properties and functions.</li>
</ul>
<p>The typed signature is certainly longer than the untyped one, but :string, :JQueryAjaxSettings, and JQueryXHR are not clutter. They are important documentation that improves the comprehensibility of the code. We can understand the code to a much greater degree without having to dive into the implementation or reading the docs. My personal experience is that I can read the typed code faster because types provide more context to understand the code. But if any of the readers can find a study on how types affect code readability, please leave a comment.</p>
<p>One thing that is different about TypeScript comparing to many other languages compiled to JavaScript is that its type annotations are optional, and jQuery.ajax(url, settings) is still valid TypeScript. So instead of an on-off switch, TypeScript’s types are more of a dial. If you find that the code is trivial to read and understand without type annotations, do not use them. <strong>Use types only when they add value.</strong></p>
<h4 id="Does-TypeScript-Limit-Expressiveness"><a href="#Does-TypeScript-Limit-Expressiveness" class="headerlink" title="Does TypeScript Limit Expressiveness?"></a>Does TypeScript Limit Expressiveness?</h4><p>Dynamically-typed languages have inferior tooling, but they are more malleable and expressive. I think using TypeScript makes your code more rigid, but to a much lesser degree than people think. Let me show you what I mean. Let’s say I use ImmutableJS to define the Person record.</p>
<p>How do we type the record? Let’s start with defining an interface called Person:</p>
<p>If we try to do the following:</p>
<p>the TypeScript compiler will complain. It does not know that PersonRecord is actually compatible with Person because PersonRecord is created reflectively. Some of you with the FP background are probably saying: “If only TypeScript had dependent types!” But it does not. TypeScript’s type system is not the most advanced one. But its goal is different. It is not here to prove that the program is 100% correct. It is about giving you more information and enable greater tooling. So it is OK to take shortcuts when the type system is not flexible enough. So we can just cast the created record, as follows:</p>
<p>The typed example:</p>
<p>The reason why it works is because the type system is structural. As long as the created object has the right fields — name and age — we are good.</p>
<p>You need to embrace the mindset that it is OK to take shortcuts when working with TypeScript. Only then you will find using the language enjoyable. For instance, don’t try to add types to some funky metaprogramming code — most likely you won’t be able to express it statically. Type everything around that code, and tell the typechecker to ignore the funky bit. In this case you will not lose a lot of expressiveness, and the bulk of your code will remain toolable and analyzable.</p>
<p>This is similar to trying to get 100% unit test code coverage. Whereas getting 95% is usually not that difficult, getting 100% can be challenging, and may negatively affect the architecture of your application.</p>
<p><strong>The optional type system also preserves the JavaScript development workflow. Large parts of your application’s code base can be “broken”, but you can still run it. TypeScript will keep generating JavaScript, even when the type checker complains. This is extremely useful during development.</strong></p>
<h4 id="Why-TypeScript"><a href="#Why-TypeScript" class="headerlink" title="Why TypeScript?"></a>Why TypeScript?</h4><p>There are a lot of options available to frontend devs today: ES5, ES6 (Babel), TypeScript, Dart, PureScript, Elm, etc.. So why TypeScript?</p>
<p>Let’s start with ES5. ES5 has one significant advantage over TypeScript: it does not require a transpiler. This allows you to keep your build setup simple. You do not need to set up file watchers, transpile code, generate source maps. It just works.</p>
<p>ES6 requires a transpiler, so the build setup will not be much different from TypeScript. But it is a standard, which means that every single editor and build tool either supports ES6 or will support it. This is a weaker argument that it used to be as most editors at this point have excellent TypeScript support.</p>
<p>Elm and PureScript are elegant languages with powerful type systems that can prove a lot more about your program than TypeScript can. The code written in Elm and PureScript can be a lot terser than similar code written in ES5.</p>
<p>Each of these options has pros and cons, but I think TypeScript is in a sweet spot that makes it a great choice for most projects. <strong>TypeScript takes 95% of the usefulness of a good statically-typed language and brings it to the JavaScript ecosystem. You still feel like you write ES6: you keep using the same standard library, same third-party libraries, same idioms, and many of the same tools (e.g., Chrome dev tools). It gives you a lot without forcing you out of the JavaScript ecosystem.</strong></p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    
<script>
  if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-85094676-2', 'auto');
    ga('send', 'pageview');
  }
</script>



    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/Angular2-Training-Book/script/doc.js"></script>

    

  </body>
</html>
